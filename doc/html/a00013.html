<!-- XHTML 1.0 Strict -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<meta name="author" content="Rachid Touzani" />
<meta name="keywords" content=" css, dropdowns, dropdown menu, drop-down, menu, navigation, nav, horizontal, vertical left-to-right, vertical right-to-left, horizontal linear, horizontal upwards, cross browser, internet explorer, ie, firefox, safari, opera, browser, lwis" />
<meta name="description" content="Clean, standards-friendly, modular framework for dropdown menus" />
<link href="../css/dropdown.vertical.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../css/default.ultimate.css" media="screen" rel="stylesheet" type="text/css" />
<head>
<!-- Title -->
<title>OFELI - Documentation</title>
<!-- Stylesheet -->
<link rel="stylesheet" type="text/css" href="../doxygen.css" />
<link rel="stylesheet" type="text/css" href="../tabs.css" />
</head>
<body>
<p align="center">
  <img src="../ofeli.gif" alt="OFELI's Logo" width="300" height="90">
</p>
<p align="center"><font color="#203F5B" size="4" face="verdana,Helvetica">
<b>An Object Oriented Finite Element Library</b></font></p>
<!-- Complete Page-->
<div id="main">
<div id="mainmenu">
 <div class="text">
<!-- Menu -->
 <div class="tabs">
  <ul class="tablist">
   <li><a href="../index.html"><span>Home</span></a>
    <li><a href="../overview.html"><span>Overview</span></a>
    <li><a href="../extlib.html"><span>External Libraries</span></a>
    <li><a href="../citing.html"><span>Citing OFELI</span></a>
    <li><a href="../fformats.html"><span>File Formats</span></a>
    <li><a href="../demos.html"><span>Demo Codes</span></a>
  </ul>
 </div>
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00323.html">OFELI</a></li><li class="navelem"><a class="el" href="a00013.html">DMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a00386.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DMatrix&lt; T_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00341.html">OFELI</a><a class="el" href="a00341.html">OFELI</a> &raquo;  &#124; <a class="el" href="a00335.html">Vector and Matrix</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>To handle dense matrices.  
 <a href="a00013.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for DMatrix&lt; T_ &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00387.png" border="0" usemap="#DMatrix_3_01T___01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="DMatrix_3_01T___01_4_inherit__map" id="DMatrix_3_01T___01_4_inherit__map">
<area shape="rect" id="node2" href="a00070.html" title="Virtual class to handle matrices for all storage formats. " alt="" coords="10,5,107,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for DMatrix&lt; T_ &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="a00388.png" border="0" usemap="#DMatrix_3_01T___01_4_coll__map" alt="Collaboration graph"/></div>
<map name="DMatrix_3_01T___01_4_coll__map" id="DMatrix_3_01T___01_4_coll__map">
<area shape="rect" id="node2" href="a00070.html" title="Virtual class to handle matrices for all storage formats. " alt="" coords="10,5,107,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc239829c455123e8aac9f7cae78b968"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#afc239829c455123e8aac9f7cae78b968">DMatrix</a> ()</td></tr>
<tr class="memdesc:afc239829c455123e8aac9f7cae78b968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#afc239829c455123e8aac9f7cae78b968">More...</a><br /></td></tr>
<tr class="separator:afc239829c455123e8aac9f7cae78b968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a5daf8bc8e4099e3ec44d86762c835"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ae6a5daf8bc8e4099e3ec44d86762c835">DMatrix</a> (size_t nr)</td></tr>
<tr class="memdesc:ae6a5daf8bc8e4099e3ec44d86762c835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a matrix with <code>nr</code> rows and <code>nr</code> columns.  <a href="#ae6a5daf8bc8e4099e3ec44d86762c835">More...</a><br /></td></tr>
<tr class="separator:ae6a5daf8bc8e4099e3ec44d86762c835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129bf5624725a68a0602aed6452bfe6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a129bf5624725a68a0602aed6452bfe6b">DMatrix</a> (size_t nr, size_t nc)</td></tr>
<tr class="memdesc:a129bf5624725a68a0602aed6452bfe6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for a matrix with <code>nr</code> rows and <code>nc</code> columns.  <a href="#a129bf5624725a68a0602aed6452bfe6b">More...</a><br /></td></tr>
<tr class="separator:a129bf5624725a68a0602aed6452bfe6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b8942efb928b84b44339b5dfba10ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a21b8942efb928b84b44339b5dfba10ae">DMatrix</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;v)</td></tr>
<tr class="memdesc:a21b8942efb928b84b44339b5dfba10ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that uses a <a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance. The class uses the memory space occupied by this vector.  <a href="#a21b8942efb928b84b44339b5dfba10ae">More...</a><br /></td></tr>
<tr class="separator:a21b8942efb928b84b44339b5dfba10ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d49496c7c63a0512f8628d52aad20bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a5d49496c7c63a0512f8628d52aad20bb">DMatrix</a> (const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a5d49496c7c63a0512f8628d52aad20bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor.  <a href="#a5d49496c7c63a0512f8628d52aad20bb">More...</a><br /></td></tr>
<tr class="separator:a5d49496c7c63a0512f8628d52aad20bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb7360ae80562139b3be162f7aa6efa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#acbb7360ae80562139b3be162f7aa6efa">DMatrix</a> (<a class="el" href="a00071.html">Mesh</a> &amp;mesh, size_t dof=0, int is_diagonal=false)</td></tr>
<tr class="memdesc:acbb7360ae80562139b3be162f7aa6efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor using mesh to initialize structure of matrix.  <a href="#acbb7360ae80562139b3be162f7aa6efa">More...</a><br /></td></tr>
<tr class="separator:acbb7360ae80562139b3be162f7aa6efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d58c077392c7226d414c1391d70a6d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d58c077392c7226d414c1391d70a6d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a8d58c077392c7226d414c1391d70a6d5">~DMatrix</a> ()</td></tr>
<tr class="memdesc:a8d58c077392c7226d414c1391d70a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a8d58c077392c7226d414c1391d70a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e475404ab75bd6cfe18a2aeb76a7de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ac4e475404ab75bd6cfe18a2aeb76a7de">setDiag</a> ()</td></tr>
<tr class="memdesc:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store diagonal entries in a separate internal vector. <br /></td></tr>
<tr class="separator:ac4e475404ab75bd6cfe18a2aeb76a7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada43e388310892d120dc1e2e2f9841ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ada43e388310892d120dc1e2e2f9841ea">setDiag</a> (const T_ &amp;a)</td></tr>
<tr class="memdesc:ada43e388310892d120dc1e2e2f9841ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix as diagonal and assign its diagonal entries as a constant.  <a href="#ada43e388310892d120dc1e2e2f9841ea">More...</a><br /></td></tr>
<tr class="separator:ada43e388310892d120dc1e2e2f9841ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#aa98bbfc7e1ef49f12a4eae45c0d0bf17">setDiag</a> (const vector&lt; T_ &gt; &amp;d)</td></tr>
<tr class="memdesc:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix as diagonal and assign its diagonal entries.  <a href="#aa98bbfc7e1ef49f12a4eae45c0d0bf17">More...</a><br /></td></tr>
<tr class="separator:aa98bbfc7e1ef49f12a4eae45c0d0bf17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97deb13018c1b55b18bfe25a9e339e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a97deb13018c1b55b18bfe25a9e339e8d">setSize</a> (size_t <a class="el" href="a00070.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a>)</td></tr>
<tr class="memdesc:a97deb13018c1b55b18bfe25a9e339e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size (number of rows) of matrix.  <a href="#a97deb13018c1b55b18bfe25a9e339e8d">More...</a><br /></td></tr>
<tr class="separator:a97deb13018c1b55b18bfe25a9e339e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd98f8e60c54091bc2249e99677f8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a6cd98f8e60c54091bc2249e99677f8c3">setSize</a> (size_t nr, size_t nc)</td></tr>
<tr class="memdesc:a6cd98f8e60c54091bc2249e99677f8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set size (number of rows and columns) of matrix.  <a href="#a6cd98f8e60c54091bc2249e99677f8c3">More...</a><br /></td></tr>
<tr class="separator:a6cd98f8e60c54091bc2249e99677f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6afdfede402d3a49733ee7fc461625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a1c6afdfede402d3a49733ee7fc461625">getColumn</a> (size_t j, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;v) const </td></tr>
<tr class="memdesc:a1c6afdfede402d3a49733ee7fc461625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>j</code>-th column vector.  <a href="#a1c6afdfede402d3a49733ee7fc461625">More...</a><br /></td></tr>
<tr class="separator:a1c6afdfede402d3a49733ee7fc461625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a41b22a9bdb6e7816adda67eb2b3fcadd">getColumn</a> (size_t j) const </td></tr>
<tr class="memdesc:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>j</code>-th column vector.  <a href="#a41b22a9bdb6e7816adda67eb2b3fcadd">More...</a><br /></td></tr>
<tr class="separator:a41b22a9bdb6e7816adda67eb2b3fcadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a97237e5c52ffcc6fae8abd88c795b1f4">getRow</a> (size_t i, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;v) const </td></tr>
<tr class="memdesc:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>i</code>-th row vector.  <a href="#a97237e5c52ffcc6fae8abd88c795b1f4">More...</a><br /></td></tr>
<tr class="separator:a97237e5c52ffcc6fae8abd88c795b1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4442e9e5d2d998bdeed7382f72416c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#aca4442e9e5d2d998bdeed7382f72416c">getRow</a> (size_t i) const </td></tr>
<tr class="memdesc:aca4442e9e5d2d998bdeed7382f72416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get <code>i</code>-th row vector.  <a href="#aca4442e9e5d2d998bdeed7382f72416c">More...</a><br /></td></tr>
<tr class="separator:aca4442e9e5d2d998bdeed7382f72416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cf373a94a5fedbca306e016bc489c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a61cf373a94a5fedbca306e016bc489c9">set</a> (size_t i, size_t j, const T_ &amp;val)</td></tr>
<tr class="memdesc:a61cf373a94a5fedbca306e016bc489c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a constant value to an entry of the matrix.  <a href="#a61cf373a94a5fedbca306e016bc489c9">More...</a><br /></td></tr>
<tr class="separator:a61cf373a94a5fedbca306e016bc489c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20897c5c8bd47f5d4005989bead0e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ad20897c5c8bd47f5d4005989bead0e55">reset</a> ()</td></tr>
<tr class="memdesc:ad20897c5c8bd47f5d4005989bead0e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set matrix to 0 and reset factorization parameter.  <a href="#ad20897c5c8bd47f5d4005989bead0e55">More...</a><br /></td></tr>
<tr class="separator:ad20897c5c8bd47f5d4005989bead0e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0e68c1876d30d52009f2da7b70bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#aef0e68c1876d30d52009f2da7b70bac4">setRow</a> (size_t i, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;v)</td></tr>
<tr class="memdesc:aef0e68c1876d30d52009f2da7b70bac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a given vector to a prescribed row in the matrix.  <a href="#aef0e68c1876d30d52009f2da7b70bac4">More...</a><br /></td></tr>
<tr class="separator:aef0e68c1876d30d52009f2da7b70bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6676c0ae519b1521591486fdfd798c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#afa6676c0ae519b1521591486fdfd798c">setColumn</a> (size_t j, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;v)</td></tr>
<tr class="memdesc:afa6676c0ae519b1521591486fdfd798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a given vector to a prescribed column in the matrix.  <a href="#afa6676c0ae519b1521591486fdfd798c">More...</a><br /></td></tr>
<tr class="separator:afa6676c0ae519b1521591486fdfd798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182aa2a623c3a9e200cc74350c173c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a182aa2a623c3a9e200cc74350c173c9b">MultAdd</a> (T_ a, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a182aa2a623c3a9e200cc74350c173c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>a*x</code> and add result to <code>y</code>.  <a href="#a182aa2a623c3a9e200cc74350c173c9b">More...</a><br /></td></tr>
<tr class="separator:a182aa2a623c3a9e200cc74350c173c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891baacc01ccea53b33d0da6fd57d653"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a891baacc01ccea53b33d0da6fd57d653">MultAdd</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a891baacc01ccea53b33d0da6fd57d653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>x</code> and add result to <code>y</code>.  <a href="#a891baacc01ccea53b33d0da6fd57d653">More...</a><br /></td></tr>
<tr class="separator:a891baacc01ccea53b33d0da6fd57d653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#af3a7c8856e21eb23fa804f0d2f6e893b">Mult</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply matrix by vector <code>x</code> and save result in <code>y</code>.  <a href="#af3a7c8856e21eb23fa804f0d2f6e893b">More...</a><br /></td></tr>
<tr class="separator:af3a7c8856e21eb23fa804f0d2f6e893b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d263a3302f9ee2a9a6401080ce9b90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a46d263a3302f9ee2a9a6401080ce9b90">TMult</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;y) const </td></tr>
<tr class="memdesc:a46d263a3302f9ee2a9a6401080ce9b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply transpose of matrix by vector <code>x</code> and add result in <code>y</code>.  <a href="#a46d263a3302f9ee2a9a6401080ce9b90">More...</a><br /></td></tr>
<tr class="separator:a46d263a3302f9ee2a9a6401080ce9b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17592a65d5fb95d42c07f724dabad759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a17592a65d5fb95d42c07f724dabad759">add</a> (size_t i, size_t j, const T_ &amp;val)</td></tr>
<tr class="memdesc:a17592a65d5fb95d42c07f724dabad759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add constant <code>val</code> to entry <code>(i,j)</code> of the matrix.  <a href="#a17592a65d5fb95d42c07f724dabad759">More...</a><br /></td></tr>
<tr class="separator:a17592a65d5fb95d42c07f724dabad759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc985b7750f99e19eb4afff8554ffee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a7dc985b7750f99e19eb4afff8554ffee">Axpy</a> (T_ a, const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a7dc985b7750f99e19eb4afff8554ffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to matrix the product of a matrix by a scalar.  <a href="#a7dc985b7750f99e19eb4afff8554ffee">More...</a><br /></td></tr>
<tr class="separator:a7dc985b7750f99e19eb4afff8554ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ecd57722b088d883cdb26ac2887270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ac7ecd57722b088d883cdb26ac2887270">Axpy</a> (T_ a, const <a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; *m)</td></tr>
<tr class="memdesc:ac7ecd57722b088d883cdb26ac2887270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add to matrix the product of a matrix by a scalar.  <a href="#ac7ecd57722b088d883cdb26ac2887270">More...</a><br /></td></tr>
<tr class="separator:ac7ecd57722b088d883cdb26ac2887270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06df703042b225fd23143f274855f5af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a06df703042b225fd23143f274855f5af">setQR</a> ()</td></tr>
<tr class="memdesc:a06df703042b225fd23143f274855f5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a QR factorization of the matrix.  <a href="#a06df703042b225fd23143f274855f5af">More...</a><br /></td></tr>
<tr class="separator:a06df703042b225fd23143f274855f5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fff3cc76da3fb94123915cc10d9739"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a99fff3cc76da3fb94123915cc10d9739">setTransQR</a> ()</td></tr>
<tr class="memdesc:a99fff3cc76da3fb94123915cc10d9739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a QR factorization of the transpose of the matrix.  <a href="#a99fff3cc76da3fb94123915cc10d9739">More...</a><br /></td></tr>
<tr class="separator:a99fff3cc76da3fb94123915cc10d9739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d732d89ba95b550c98b33cf1a29630f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a5d732d89ba95b550c98b33cf1a29630f">solveQR</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x)</td></tr>
<tr class="memdesc:a5d732d89ba95b550c98b33cf1a29630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system by QR decomposition.  <a href="#a5d732d89ba95b550c98b33cf1a29630f">More...</a><br /></td></tr>
<tr class="separator:a5d732d89ba95b550c98b33cf1a29630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3a02f81b0cd213d97e647d75881a71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a5c3a02f81b0cd213d97e647d75881a71">solveTransQR</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x)</td></tr>
<tr class="memdesc:a5c3a02f81b0cd213d97e647d75881a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a transpose linear system by QR decomposition.  <a href="#a5c3a02f81b0cd213d97e647d75881a71">More...</a><br /></td></tr>
<tr class="separator:a5c3a02f81b0cd213d97e647d75881a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d11677b77c61b1c2530c0295d9a966"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#af4d11677b77c61b1c2530c0295d9a966">operator()</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:af4d11677b77c61b1c2530c0295d9a966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () (Constant version). Return <code>a(i,j)</code>  <a href="#af4d11677b77c61b1c2530c0295d9a966">More...</a><br /></td></tr>
<tr class="separator:af4d11677b77c61b1c2530c0295d9a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906d09665a54a68d6333925dc83c57c8"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a906d09665a54a68d6333925dc83c57c8">operator()</a> (size_t i, size_t j)</td></tr>
<tr class="memdesc:a906d09665a54a68d6333925dc83c57c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () (Non constant version). Return <code>a(i,j)</code>  <a href="#a906d09665a54a68d6333925dc83c57c8">More...</a><br /></td></tr>
<tr class="separator:a906d09665a54a68d6333925dc83c57c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254526dadd3fc5f1ffa120bfb2357f23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a254526dadd3fc5f1ffa120bfb2357f23">setLU</a> ()</td></tr>
<tr class="memdesc:a254526dadd3fc5f1ffa120bfb2357f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the matrix (LU factorization)  <a href="#a254526dadd3fc5f1ffa120bfb2357f23">More...</a><br /></td></tr>
<tr class="separator:a254526dadd3fc5f1ffa120bfb2357f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff4d2dbffcb0aae37478fa006a65ad2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#acff4d2dbffcb0aae37478fa006a65ad2">setTransLU</a> ()</td></tr>
<tr class="memdesc:acff4d2dbffcb0aae37478fa006a65ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the transpose of the matrix (LU factorization)  <a href="#acff4d2dbffcb0aae37478fa006a65ad2">More...</a><br /></td></tr>
<tr class="separator:acff4d2dbffcb0aae37478fa006a65ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abe8e904adb7fd09103d7b3e8e362d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a85abe8e904adb7fd09103d7b3e8e362d">solve</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, bool fact=true)</td></tr>
<tr class="memdesc:a85abe8e904adb7fd09103d7b3e8e362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system.  <a href="#a85abe8e904adb7fd09103d7b3e8e362d">More...</a><br /></td></tr>
<tr class="separator:a85abe8e904adb7fd09103d7b3e8e362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8ceb5529d6626cf6cbb2bd4b227cee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#abd8ceb5529d6626cf6cbb2bd4b227cee">solveTrans</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, bool fact=true)</td></tr>
<tr class="memdesc:abd8ceb5529d6626cf6cbb2bd4b227cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the transpose linear system.  <a href="#abd8ceb5529d6626cf6cbb2bd4b227cee">More...</a><br /></td></tr>
<tr class="separator:abd8ceb5529d6626cf6cbb2bd4b227cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c662f32ce66be2efa47871358fcf10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a27c662f32ce66be2efa47871358fcf10">solve</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, bool fact=true)</td></tr>
<tr class="memdesc:a27c662f32ce66be2efa47871358fcf10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system.  <a href="#a27c662f32ce66be2efa47871358fcf10">More...</a><br /></td></tr>
<tr class="separator:a27c662f32ce66be2efa47871358fcf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e7f24569d9dc2dad452eb203662c62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#aa1e7f24569d9dc2dad452eb203662c62">solveTrans</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x, bool fact=true)</td></tr>
<tr class="memdesc:aa1e7f24569d9dc2dad452eb203662c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the transpose linear system.  <a href="#aa1e7f24569d9dc2dad452eb203662c62">More...</a><br /></td></tr>
<tr class="separator:aa1e7f24569d9dc2dad452eb203662c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e95a9612c9f9580b8a17c9b7b274ef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a3e95a9612c9f9580b8a17c9b7b274ef3">operator=</a> (<a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e95a9612c9f9580b8a17c9b7b274ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>=</code>  <a href="#a3e95a9612c9f9580b8a17c9b7b274ef3">More...</a><br /></td></tr>
<tr class="separator:a3e95a9612c9f9580b8a17c9b7b274ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96923df00240d52550326b4b0d55299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#af96923df00240d52550326b4b0d55299">operator+=</a> (const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:af96923df00240d52550326b4b0d55299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator +=.  <a href="#af96923df00240d52550326b4b0d55299">More...</a><br /></td></tr>
<tr class="separator:af96923df00240d52550326b4b0d55299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189a781e41f75e17832c7f641f6789c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a189a781e41f75e17832c7f641f6789c1">operator-=</a> (const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a189a781e41f75e17832c7f641f6789c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -=.  <a href="#a189a781e41f75e17832c7f641f6789c1">More...</a><br /></td></tr>
<tr class="separator:a189a781e41f75e17832c7f641f6789c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85356981a1060ca3eacbd2cc6b8eab68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a85356981a1060ca3eacbd2cc6b8eab68">operator=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a85356981a1060ca3eacbd2cc6b8eab68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>=</code>  <a href="#a85356981a1060ca3eacbd2cc6b8eab68">More...</a><br /></td></tr>
<tr class="separator:a85356981a1060ca3eacbd2cc6b8eab68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbc1da088d311cb21f94180e9bb9440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a9fbc1da088d311cb21f94180e9bb9440">operator*=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a9fbc1da088d311cb21f94180e9bb9440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>*=</code>  <a href="#a9fbc1da088d311cb21f94180e9bb9440">More...</a><br /></td></tr>
<tr class="separator:a9fbc1da088d311cb21f94180e9bb9440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c50402f35d15c121ddc3dcf1e48c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ae5c50402f35d15c121ddc3dcf1e48c59">operator+=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:ae5c50402f35d15c121ddc3dcf1e48c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>+=</code>  <a href="#ae5c50402f35d15c121ddc3dcf1e48c59">More...</a><br /></td></tr>
<tr class="separator:ae5c50402f35d15c121ddc3dcf1e48c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9d3201b7c344de4c001a0091fd9c4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00013.html">DMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#afd9d3201b7c344de4c001a0091fd9c4a">operator-=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:afd9d3201b7c344de4c001a0091fd9c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator <code>-=</code>  <a href="#afd9d3201b7c344de4c001a0091fd9c4a">More...</a><br /></td></tr>
<tr class="separator:afd9d3201b7c344de4c001a0091fd9c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094470ce0ea2e96ada8f1c888230a520"><td class="memItemLeft" align="right" valign="top">T_ *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a094470ce0ea2e96ada8f1c888230a520">getArray</a> () const </td></tr>
<tr class="memdesc:a094470ce0ea2e96ada8f1c888230a520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix as C-Array.  <a href="#a094470ce0ea2e96ada8f1c888230a520">More...</a><br /></td></tr>
<tr class="separator:a094470ce0ea2e96ada8f1c888230a520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b1d2724593a6ec1212247d7964b8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a7b1d2724593a6ec1212247d7964b8e"></a>
T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a7a7b1d2724593a6ec1212247d7964b8e">get</a> (size_t i, size_t j) const </td></tr>
<tr class="memdesc:a7a7b1d2724593a6ec1212247d7964b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return entry <code>(i,j)</code> of matrix. <br /></td></tr>
<tr class="separator:a7a7b1d2724593a6ec1212247d7964b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_a00070"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_a00070')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="a00070.html">Matrix&lt; T_ &gt;</a></td></tr>
<tr class="memitem:a3aede62f513da27e6f61ae7a972b4f96 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a3aede62f513da27e6f61ae7a972b4f96">Matrix</a> ()</td></tr>
<tr class="memdesc:a3aede62f513da27e6f61ae7a972b4f96 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3aede62f513da27e6f61ae7a972b4f96">More...</a><br /></td></tr>
<tr class="separator:a3aede62f513da27e6f61ae7a972b4f96 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a08c31941b608d62de67b028e19ca8d inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a08c31941b608d62de67b028e19ca8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a4a08c31941b608d62de67b028e19ca8d">Matrix</a> (const <a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a4a08c31941b608d62de67b028e19ca8d inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br /></td></tr>
<tr class="separator:a4a08c31941b608d62de67b028e19ca8d inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50937512a2aece401826a35ccdf69f3b inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50937512a2aece401826a35ccdf69f3b"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a50937512a2aece401826a35ccdf69f3b">~Matrix</a> ()</td></tr>
<tr class="memdesc:a50937512a2aece401826a35ccdf69f3b inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a50937512a2aece401826a35ccdf69f3b inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64de7025d9f5712288b3093ca5408b1 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac64de7025d9f5712288b3093ca5408b1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ac64de7025d9f5712288b3093ca5408b1">getNbRows</a> () const </td></tr>
<tr class="memdesc:ac64de7025d9f5712288b3093ca5408b1 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of rows. <br /></td></tr>
<tr class="separator:ac64de7025d9f5712288b3093ca5408b1 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879356293a4c2120a7f87bf231ce341c inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a879356293a4c2120a7f87bf231ce341c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a879356293a4c2120a7f87bf231ce341c">getNbColumns</a> () const </td></tr>
<tr class="memdesc:a879356293a4c2120a7f87bf231ce341c inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of columns. <br /></td></tr>
<tr class="separator:a879356293a4c2120a7f87bf231ce341c inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72077468b17118c44394d286f7737bd4 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72077468b17118c44394d286f7737bd4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a72077468b17118c44394d286f7737bd4">setPenal</a> (<a class="el" href="a00334.html#gaccfeb6b1e8cf41731fde610549bee67c">real_t</a> p)</td></tr>
<tr class="memdesc:a72077468b17118c44394d286f7737bd4 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Penalty Parameter (For boundary condition prescription). <br /></td></tr>
<tr class="separator:a72077468b17118c44394d286f7737bd4 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282ce97ddc94a4ad0030c047b35332ca inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a282ce97ddc94a4ad0030c047b35332ca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a282ce97ddc94a4ad0030c047b35332ca">setDiagonal</a> ()</td></tr>
<tr class="memdesc:a282ce97ddc94a4ad0030c047b35332ca inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the matrix as diagonal. <br /></td></tr>
<tr class="separator:a282ce97ddc94a4ad0030c047b35332ca inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fae0c47b38f34c0c764b2b6109f9d5 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a06fae0c47b38f34c0c764b2b6109f9d5">getDiag</a> (size_t k) const </td></tr>
<tr class="memdesc:a06fae0c47b38f34c0c764b2b6109f9d5 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>k</code>-th diagonal entry of matrix.  <a href="#a06fae0c47b38f34c0c764b2b6109f9d5">More...</a><br /></td></tr>
<tr class="separator:a06fae0c47b38f34c0c764b2b6109f9d5 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac782da1f912bceb5d8ad00c8dc892ac inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac782da1f912bceb5d8ad00c8dc892ac"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a> () const </td></tr>
<tr class="memdesc:aac782da1f912bceb5d8ad00c8dc892ac inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix dimension (Number of rows and columns). <br /></td></tr>
<tr class="separator:aac782da1f912bceb5d8ad00c8dc892ac inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196d9e08fa42335a41f8e67082215065 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a196d9e08fa42335a41f8e67082215065">setDiagonal</a> (<a class="el" href="a00071.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a196d9e08fa42335a41f8e67082215065 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize matrix storage in the case where only diagonal terms are stored.  <a href="#a196d9e08fa42335a41f8e67082215065">More...</a><br /></td></tr>
<tr class="separator:a196d9e08fa42335a41f8e67082215065 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae048282c7011eedc2e0492f6421ea73 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae048282c7011eedc2e0492f6421ea73"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aae048282c7011eedc2e0492f6421ea73">clear</a> ()</td></tr>
<tr class="memdesc:aae048282c7011eedc2e0492f6421ea73 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief Set all matrix entries to zero <br /></td></tr>
<tr class="separator:aae048282c7011eedc2e0492f6421ea73 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8f063011ae37198a6c96ad00da6188 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aae8f063011ae37198a6c96ad00da6188">Assembly</a> (const <a class="el" href="a00025.html">Element</a> &amp;el, T_ *a)</td></tr>
<tr class="memdesc:aae8f063011ae37198a6c96ad00da6188 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of element matrix into global matrix.  <a href="#aae8f063011ae37198a6c96ad00da6188">More...</a><br /></td></tr>
<tr class="separator:aae8f063011ae37198a6c96ad00da6188 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377c96d9edc5455d8b81d7f2e75a7437 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a377c96d9edc5455d8b81d7f2e75a7437">Assembly</a> (const <a class="el" href="a00097.html">Side</a> &amp;sd, T_ *a)</td></tr>
<tr class="memdesc:a377c96d9edc5455d8b81d7f2e75a7437 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly of side matrix into global matrix.  <a href="#a377c96d9edc5455d8b81d7f2e75a7437">More...</a><br /></td></tr>
<tr class="separator:a377c96d9edc5455d8b81d7f2e75a7437 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1775cd968f5d809fed17f111c852a8f4 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a1775cd968f5d809fed17f111c852a8f4">Prescribe</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a1775cd968f5d809fed17f111c852a8f4 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition, using the <a class="el" href="a00071.html" title="To store and manipulate finite element meshes. ">Mesh</a> instance provided by the constructor.  <a href="#a1775cd968f5d809fed17f111c852a8f4">More...</a><br /></td></tr>
<tr class="separator:a1775cd968f5d809fed17f111c852a8f4 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9143a391d39e2b1c8fc092d18a2c01 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a5e9143a391d39e2b1c8fc092d18a2c01">Prescribe</a> (int dof, int code, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a5e9143a391d39e2b1c8fc092d18a2c01 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition to a given degree of freedom for a given code.  <a href="#a5e9143a391d39e2b1c8fc092d18a2c01">More...</a><br /></td></tr>
<tr class="separator:a5e9143a391d39e2b1c8fc092d18a2c01 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d58b8c69697615bb891ad8d89192e11 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a3d58b8c69697615bb891ad8d89192e11">Prescribe</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, int flag=0)</td></tr>
<tr class="memdesc:a3d58b8c69697615bb891ad8d89192e11 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method a homegeneous (=0) essential boundary condition.  <a href="#a3d58b8c69697615bb891ad8d89192e11">More...</a><br /></td></tr>
<tr class="separator:a3d58b8c69697615bb891ad8d89192e11 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a278a1ed1bb0a7a6df613e63816c8cf inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a0a278a1ed1bb0a7a6df613e63816c8cf">Prescribe</a> (size_t dof, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;u, int flag=0)</td></tr>
<tr class="memdesc:a0a278a1ed1bb0a7a6df613e63816c8cf inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition when only one DOF is treated.  <a href="#a0a278a1ed1bb0a7a6df613e63816c8cf">More...</a><br /></td></tr>
<tr class="separator:a0a278a1ed1bb0a7a6df613e63816c8cf inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4668862b3d13a8ac8ffec768b7e38631 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a4668862b3d13a8ac8ffec768b7e38631">PrescribeSide</a> ()</td></tr>
<tr class="memdesc:a4668862b3d13a8ac8ffec768b7e38631 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose by a penalty method an essential boundary condition when DOFs are supported by sides.  <a href="#a4668862b3d13a8ac8ffec768b7e38631">More...</a><br /></td></tr>
<tr class="separator:a4668862b3d13a8ac8ffec768b7e38631 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f6b1105cb4953c3f56b5c51ed4b046 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9f6b1105cb4953c3f56b5c51ed4b046"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ab9f6b1105cb4953c3f56b5c51ed4b046">Factor</a> ()=0</td></tr>
<tr class="memdesc:ab9f6b1105cb4953c3f56b5c51ed4b046 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix. Available only if the storage class enables it. <br /></td></tr>
<tr class="separator:ab9f6b1105cb4953c3f56b5c51ed4b046 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ebb919bf4d6e5e646c1c113392a79 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#af70ebb919bf4d6e5e646c1c113392a79">FactorAndSolve</a> (<a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>)</td></tr>
<tr class="memdesc:af70ebb919bf4d6e5e646c1c113392a79 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix and solve the linear system.  <a href="#af70ebb919bf4d6e5e646c1c113392a79">More...</a><br /></td></tr>
<tr class="separator:af70ebb919bf4d6e5e646c1c113392a79 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20265f18b86fdc36c0c694d34bb01db inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ad20265f18b86fdc36c0c694d34bb01db">FactorAndSolve</a> (const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;<a class="el" href="a00341.html#gaf5cd2eaaceda19772fd904539819158c">b</a>, <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;x)</td></tr>
<tr class="memdesc:ad20265f18b86fdc36c0c694d34bb01db inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize matrix and solve the linear system.  <a href="#ad20265f18b86fdc36c0c694d34bb01db">More...</a><br /></td></tr>
<tr class="separator:ad20265f18b86fdc36c0c694d34bb01db inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d4c55c333f8db2cc206b90b1e53041 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d4c55c333f8db2cc206b90b1e53041"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a68d4c55c333f8db2cc206b90b1e53041">getLength</a> () const </td></tr>
<tr class="memdesc:a68d4c55c333f8db2cc206b90b1e53041 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of stored terms in matrix. <br /></td></tr>
<tr class="separator:a68d4c55c333f8db2cc206b90b1e53041 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01047a7f68670914394281ab80f89947 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01047a7f68670914394281ab80f89947"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a01047a7f68670914394281ab80f89947">isDiagonal</a> () const </td></tr>
<tr class="memdesc:a01047a7f68670914394281ab80f89947 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if matrix is diagonal or not. <br /></td></tr>
<tr class="separator:a01047a7f68670914394281ab80f89947 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db6c5f267140ce71d02b845638d6229 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a1db6c5f267140ce71d02b845638d6229">isFactorized</a> () const </td></tr>
<tr class="memdesc:a1db6c5f267140ce71d02b845638d6229 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Say if matrix is factorized or not.  <a href="#a1db6c5f267140ce71d02b845638d6229">More...</a><br /></td></tr>
<tr class="separator:a1db6c5f267140ce71d02b845638d6229 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6cc2fefdae6c493609bb253d571b7 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4f6cc2fefdae6c493609bb253d571b7"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#af4f6cc2fefdae6c493609bb253d571b7">getColInd</a> (size_t i) const </td></tr>
<tr class="memdesc:af4f6cc2fefdae6c493609bb253d571b7 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Column index for column <code>i</code> (See the description for class <a class="el" href="a00102.html" title="To handle matrices in sparse storage format. ">SpMatrix</a>). <br /></td></tr>
<tr class="separator:af4f6cc2fefdae6c493609bb253d571b7 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10438b6ef525d89a3fdfb549b03b4488 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10438b6ef525d89a3fdfb549b03b4488"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a10438b6ef525d89a3fdfb549b03b4488">getRowPtr</a> (size_t i) const </td></tr>
<tr class="memdesc:a10438b6ef525d89a3fdfb549b03b4488 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Row pointer for row <code>i</code> (See the description for class <a class="el" href="a00102.html" title="To handle matrices in sparse storage format. ">SpMatrix</a>). <br /></td></tr>
<tr class="separator:a10438b6ef525d89a3fdfb549b03b4488 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc9619401846e377b99d5f35e21580 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a5ddc9619401846e377b99d5f35e21580">operator()</a> (size_t i) const </td></tr>
<tr class="memdesc:a5ddc9619401846e377b99d5f35e21580 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () with one argument (Constant version).  <a href="#a5ddc9619401846e377b99d5f35e21580">More...</a><br /></td></tr>
<tr class="separator:a5ddc9619401846e377b99d5f35e21580 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fb7738730bfcc21b07ede2b6137fc9 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ad7fb7738730bfcc21b07ede2b6137fc9">operator()</a> (size_t i)</td></tr>
<tr class="memdesc:ad7fb7738730bfcc21b07ede2b6137fc9 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator () with one argument (Non Constant version).  <a href="#ad7fb7738730bfcc21b07ede2b6137fc9">More...</a><br /></td></tr>
<tr class="separator:ad7fb7738730bfcc21b07ede2b6137fc9 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760177d294663b1dd8941afd331b0fbb inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">T_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a760177d294663b1dd8941afd331b0fbb">operator[]</a> (size_t k)</td></tr>
<tr class="memdesc:a760177d294663b1dd8941afd331b0fbb inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator [] (Non constant version).  <a href="#a760177d294663b1dd8941afd331b0fbb">More...</a><br /></td></tr>
<tr class="separator:a760177d294663b1dd8941afd331b0fbb inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9fc831c3cfa8fe5b57e99da5ac1e52 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top">T_&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a0c9fc831c3cfa8fe5b57e99da5ac1e52">operator[]</a> (size_t k) const </td></tr>
<tr class="memdesc:a0c9fc831c3cfa8fe5b57e99da5ac1e52 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator [] (Constant version).  <a href="#a0c9fc831c3cfa8fe5b57e99da5ac1e52">More...</a><br /></td></tr>
<tr class="separator:a0c9fc831c3cfa8fe5b57e99da5ac1e52 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c251d473d9144bcd269aa49fd738d5 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#ae8c251d473d9144bcd269aa49fd738d5">operator=</a> (<a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:ae8c251d473d9144bcd269aa49fd738d5 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator =.  <a href="#ae8c251d473d9144bcd269aa49fd738d5">More...</a><br /></td></tr>
<tr class="separator:ae8c251d473d9144bcd269aa49fd738d5 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cbfbe86d6789ebc8b34b261402fb9a inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#aa3cbfbe86d6789ebc8b34b261402fb9a">operator+=</a> (const <a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:aa3cbfbe86d6789ebc8b34b261402fb9a inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator +=.  <a href="#aa3cbfbe86d6789ebc8b34b261402fb9a">More...</a><br /></td></tr>
<tr class="separator:aa3cbfbe86d6789ebc8b34b261402fb9a inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f89bc074972e8d49e6459ea384d672 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a82f89bc074972e8d49e6459ea384d672">operator-=</a> (const <a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; &amp;m)</td></tr>
<tr class="memdesc:a82f89bc074972e8d49e6459ea384d672 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -=.  <a href="#a82f89bc074972e8d49e6459ea384d672">More...</a><br /></td></tr>
<tr class="separator:a82f89bc074972e8d49e6459ea384d672 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd89a10218b679e5435135797da444 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a41cd89a10218b679e5435135797da444">operator=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a41cd89a10218b679e5435135797da444 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator =.  <a href="#a41cd89a10218b679e5435135797da444">More...</a><br /></td></tr>
<tr class="separator:a41cd89a10218b679e5435135797da444 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1370eca69f9880d5456fb9f4e1da44 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a7c1370eca69f9880d5456fb9f4e1da44">operator*=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a7c1370eca69f9880d5456fb9f4e1da44 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator *=.  <a href="#a7c1370eca69f9880d5456fb9f4e1da44">More...</a><br /></td></tr>
<tr class="separator:a7c1370eca69f9880d5456fb9f4e1da44 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaed73bab677150385013d0d6e138c69 inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#adaed73bab677150385013d0d6e138c69">operator+=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:adaed73bab677150385013d0d6e138c69 inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator +=.  <a href="#adaed73bab677150385013d0d6e138c69">More...</a><br /></td></tr>
<tr class="separator:adaed73bab677150385013d0d6e138c69 inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ac464768eefc4fd77ab93207c70cb inherit pub_methods_a00070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00070.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html#a778ac464768eefc4fd77ab93207c70cb">operator-=</a> (const T_ &amp;x)</td></tr>
<tr class="memdesc:a778ac464768eefc4fd77ab93207c70cb inherit pub_methods_a00070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator -=.  <a href="#a778ac464768eefc4fd77ab93207c70cb">More...</a><br /></td></tr>
<tr class="separator:a778ac464768eefc4fd77ab93207c70cb inherit pub_methods_a00070"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T_&gt;<br />
class OFELI::DMatrix&lt; T_ &gt;</h3>

<p>To handle dense matrices. </p>
<p>This class enables storing and manipulating general dense matrices. Matrices can be square or rectangle ones.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_</td><td>Data type (double, float, complex&lt;double&gt;, ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Rachid Touzani </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU Lesser Public License </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afc239829c455123e8aac9f7cae78b968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes a zero-dimension matrix. </p>

</div>
</div>
<a class="anchor" id="ae6a5daf8bc8e4099e3ec44d86762c835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a matrix with <code>nr</code> rows and <code>nr</code> columns. </p>
<p>Matrix entries are set to <code>0</code>. </p>

</div>
</div>
<a class="anchor" id="a129bf5624725a68a0602aed6452bfe6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for a matrix with <code>nr</code> rows and <code>nc</code> columns. </p>
<p><a class="el" href="a00070.html" title="Virtual class to handle matrices for all storage formats. ">Matrix</a> entries are set to 0. </p>

</div>
</div>
<a class="anchor" id="a21b8942efb928b84b44339b5dfba10ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that uses a <a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance. The class uses the memory space occupied by this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Vector to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d49496c7c63a0512f8628d52aad20bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acbb7360ae80562139b3be162f7aa6efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00071.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor using mesh to initialize structure of matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td><a class="el" href="a00071.html" title="To store and manipulate finite element meshes. ">Mesh</a> instance for which matrix graph is determined. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>Option parameter, with default value <code>0</code>.<br />
<code>dof=1</code> means that only one degree of freedom for each node (or element or side) is taken to determine matrix structure. The value <code>dof=0</code> means that matrix structure is determined using all DOFs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_diagonal</td><td>Boolean argument to say is the matrix is actually a diagonal matrix or not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ada43e388310892d120dc1e2e2f9841ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDiag </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix as diagonal and assign its diagonal entries as a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Value to assign to all diagonal entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa98bbfc7e1ef49f12a4eae45c0d0bf17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDiag </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set matrix as diagonal and assign its diagonal entries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Vector entries to assign to matrix diagonal entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97deb13018c1b55b18bfe25a9e339e8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size (number of rows) of matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of rows and columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cd98f8e60c54091bc2249e99677f8c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set size (number of rows and columns) of matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nr</td><td>Number of rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nc</td><td>Number of columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c6afdfede402d3a49733ee7fc461625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>j</code>-th column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Index of column to extract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Reference to <a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance where the column is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="a41b22a9bdb6e7816adda67eb2b3fcadd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html">Vect</a>&lt;T_&gt; getColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>j</code>-th column vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Index of column to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance where the column is stored </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="a97237e5c52ffcc6fae8abd88c795b1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>i</code>-th row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of row to extract </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v</td><td>Reference to <a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance where the row is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="aca4442e9e5d2d998bdeed7382f72416c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html">Vect</a>&lt;T_&gt; getRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get <code>i</code>-th row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>Index of row to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance where the row is stored </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Vector v does not need to be sized before. It is resized in the function </dd></dl>

</div>
</div>
<a class="anchor" id="a61cf373a94a5fedbca306e016bc489c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a constant value to an entry of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value to assign to <code>a(i,j)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#ac0cea700fd87a3493ee917937ca21796">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad20897c5c8bd47f5d4005989bead0e55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set matrix to 0 and reset factorization parameter. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function must be used if after a factorization, the matrix has modified </dd></dl>

<p>Reimplemented from <a class="el" href="a00070.html#a7b0e029102ad38f4b814c6523aedb53d">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aef0e68c1876d30d52009f2da7b70bac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a given vector to a prescribed row in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index to be assigned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa6676c0ae519b1521591486fdfd798c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setColumn </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a given vector to a prescribed column in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index to be assigned </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a182aa2a623c3a9e200cc74350c173c9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultAdd </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply matrix by vector <code>a*x</code> and add result to <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>constant to multiply by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to multiply by <code>a</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>on input, vector to add to. On output, result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a4de5f97fbbb24b50dc41e838620db33f">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a891baacc01ccea53b33d0da6fd57d653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MultAdd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply matrix by vector <code>x</code> and add result to <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to add to <code>y</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>on input, vector to add to. On output, result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a9e107d55cfee986bfe0f4f9f93cfebb1">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af3a7c8856e21eb23fa804f0d2f6e893b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply matrix by vector <code>x</code> and save result in <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to add to <code>y</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>Result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a203735f477738474b7fa91bd96284a33">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a46d263a3302f9ee2a9a6401080ce9b90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TMult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply transpose of matrix by vector <code>x</code> and add result in <code>y</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector to add to <code>y</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>on input, vector to add to. On output, result. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a1b597cd493e07b35bdd57e351ad71580">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a17592a65d5fb95d42c07f724dabad759"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add constant <code>val</code> to entry <code>(i,j)</code> of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Constant to add </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a8afb24c3d7982f994ea2c4a50444ed86">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a7dc985b7750f99e19eb4afff8554ffee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Axpy </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add to matrix the product of a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Scalar to premultiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix by which <code>a</code> is multiplied. The result is added to current instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7ecd57722b088d883cdb26ac2887270"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Axpy </td>
          <td>(</td>
          <td class="paramtype">T_&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00070.html">Matrix</a>&lt; T_ &gt; *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add to matrix the product of a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Scalar to premultiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix by which <code>a</code> is multiplied. The result is added to current instance </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#af6d9078abcad160961668918ffd89df8">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a06df703042b225fd23143f274855f5af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setQR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a QR factorization of the matrix. </p>
<p>This function constructs the QR decomposition using the Householder method. The upper triangular matrix R is returned in the upper triangle of the current matrix, except for the diagonal elements of R which are stored in an internal vector. The orthogonal matrix Q is represented as a product of n-1 Householder matrices Q1 . . . Qn-1, where Qj = 1 - uj.uj /cj . The i-th component of uj is zero for i = 1, ..., j-1 while the nonzero components are returned in a[i][j] for i = j, ..., n. </p><dl class="section return"><dt>Returns</dt><dd><code>0</code> if the decomposition was successful, <code>k</code> is the <code>k-th</code> row is singular </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The matrix can be square or rectangle </dd></dl>

</div>
</div>
<a class="anchor" id="a99fff3cc76da3fb94123915cc10d9739"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setTransQR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a QR factorization of the transpose of the matrix. </p>
<p>This function constructs the QR decomposition using the Householder method. The upper triangular matrix R is returned in the upper triangle of the current matrix, except for the diagonal elements of R which are stored in an internal vector. The orthogonal matrix Q is represented as a product of n-1 Householder matrices Q1 . . . Qn-1, where Qj = 1 - uj.uj /cj . The i-th component of uj is zero for i = 1, ..., j-1 while the nonzero components are returned in a[i][j] for i = j, ..., n. </p><dl class="section return"><dt>Returns</dt><dd><code>0</code> if the decomposition was successful, <code>k</code> is the <code>k-th</code> row is singular </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The matrix can be square or rectangle </dd></dl>

</div>
</div>
<a class="anchor" id="a5d732d89ba95b550c98b33cf1a29630f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int solveQR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a linear system by QR decomposition. </p>
<p>This function constructs the QR decomposition, if this was not already done by using the member function QR and solves the linear system </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Right-hand side vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>Solution vector. Must have been sized before using this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as returned by the function QR </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3a02f81b0cd213d97e647d75881a71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int solveTransQR </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a transpose linear system by QR decomposition. </p>
<p>This function constructs the QR decomposition, if this was not already done by using the member function QR and solves the linear system </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Right-hand side vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>Solution vector. Must have been sized before using this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as returned by the function QR </dd></dl>

</div>
</div>
<a class="anchor" id="af4d11677b77c61b1c2530c0295d9a966"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_ operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator () (Constant version). Return <code>a(i,j)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a5414ae5692942759e032a895a05f3903">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a906d09665a54a68d6333925dc83c57c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator () (Non constant version). Return <code>a(i,j)</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>column index </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="a00070.html#a98a5eea24da5bcb89516b2bd80a652d2">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a254526dadd3fc5f1ffa120bfb2357f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setLU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize the matrix (LU factorization) </p>
<p>LU factorization of the matrix is realized. Note that since this is an in place factorization, the contents of the matrix are modified. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if factorization was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A flag in this class indicates after factorization that this one has been realized, so that, if the member function solve is called after this no further factorization is done. </dd></dl>

</div>
</div>
<a class="anchor" id="acff4d2dbffcb0aae37478fa006a65ad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int setTransLU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factorize the transpose of the matrix (LU factorization) </p>
<p>LU factorization of the transpose of the matrix is realized. Note that since this is an in place factorization, the contents of the matrix are modified. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if factorization was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>A flag in this class indicates after factorization that this one has been realized, so that, if the member function solve is called after this no further factorization is done. </dd></dl>

</div>
</div>
<a class="anchor" id="a85abe8e904adb7fd09103d7b3e8e362d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve linear system. </p>
<p>The linear system having the current instance as a matrix is solved by using the LU decomposition. Solution is thus realized after a factorization step and a forward/backward substitution step. The factorization step is realized only if this was not already done.<br />
Note that this function modifies the matrix contents is a factorization is performed. Naturally, if the the matrix has been modified after using this function, the user has to refactorize it using the function setLU. This is because the class has no non-expensive way to detect if the matrix has been modified. The function setLU realizes the factorization step only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side on input and solution on output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="a00070.html#a31a4417e8d251ece6decd21307049dbf">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abd8ceb5529d6626cf6cbb2bd4b227cee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int solveTrans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the transpose linear system. </p>
<p>The linear system having the current instance as a transpose matrix is solved by using the LU decomposition. Solution is thus realized after a factorization step and a forward/backward substitution step. The factorization step is realized only if this was not already done.<br />
Note that this function modifies the matrix contents is a factorization is performed. Naturally, if the the matrix has been modified after using this function, the user has to refactorize it using the function setLU. This is because the class has no non-expensive way to detect if the matrix has been modified. The function setLU realizes the factorization step only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">b</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side on input and solution on output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a27c662f32ce66be2efa47871358fcf10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve linear system. </p>
<p>The linear system having the current instance as a matrix is solved by using the LU decomposition. Solution is thus realized after a factorization step and a forward/backward substitution step. The factorization step is realized only if this was not already done.<br />
Note that this function modifies the matrix contents is a factorization is performed. Naturally, if the the matrix has been modified after using this function, the user has to refactorize it using the function setLU. This is because the class has no non-expensive way to detect if the matrix has been modified. The function setLU realizes the factorization step only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

<p>Implements <a class="el" href="a00070.html#a4fe82250a093bea1e2d5514748574d80">Matrix&lt; T_ &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa1e7f24569d9dc2dad452eb203662c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int solveTrans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00115.html">Vect</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the transpose linear system. </p>
<p>The linear system having the current instance as a transpose matrix is solved by using the LU decomposition. Solution is thus realized after a factorization step and a forward/backward substitution step. The factorization step is realized only if this was not already done.<br />
Note that this function modifies the matrix contents is a factorization is performed. Naturally, if the the matrix has been modified after using this function, the user has to refactorize it using the function setLU. This is because the class has no non-expensive way to detect if the matrix has been modified. The function setLU realizes the factorization step only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains right-hand side. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td><a class="el" href="a00115.html" title="To handle general purpose vectors. ">Vect</a> instance that contains solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fact</td><td>Set true if matrix is to be factorized (Default value), false if not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>
<code>0</code> if solution was normally performed, </li>
<li>
<code>n</code> if the <code>n</code>-th pivot is null. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a3e95a9612c9f9580b8a17c9b7b274ef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator <code>=</code> </p>
<p>Copy matrix <code>m</code> to current matrix instance. </p>

</div>
</div>
<a class="anchor" id="af96923df00240d52550326b4b0d55299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator +=. </p>
<p>Add matrix <code>m</code> to current matrix instance. </p>

</div>
</div>
<a class="anchor" id="a189a781e41f75e17832c7f641f6789c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html">DMatrix</a>&lt; T_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator -=. </p>
<p>Subtract matrix <code>m</code> from current matrix instance. </p>

</div>
</div>
<a class="anchor" id="a85356981a1060ca3eacbd2cc6b8eab68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator <code>=</code> </p>
<p>Assign matrix to identity times <code>x</code> </p>

</div>
</div>
<a class="anchor" id="a9fbc1da088d311cb21f94180e9bb9440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator <code>*=</code> </p>
<p>Premultiply matrix entries by constant value <code>x</code>. </p>

</div>
</div>
<a class="anchor" id="ae5c50402f35d15c121ddc3dcf1e48c59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator <code>+=</code> </p>
<p>Add constant value <code>x</code> to matrix entries </p>

</div>
</div>
<a class="anchor" id="afd9d3201b7c344de4c001a0091fd9c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">DMatrix</a>&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">const T_ &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator <code>-=</code> </p>
<p>Subtract constant value <code>x</code> from matrix entries. </p>

</div>
</div>
<a class="anchor" id="a094470ce0ea2e96ada8f1c888230a520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T_* getArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return matrix as C-Array. </p>
<p>Matrix is stored row by row. </p>

</div>
</div>
</div><!-- contents -->

</div> <!-- class text -->
</div> <!-- main menu -->
<!-- Google Search -->
<!-- <br><br>
<br></p>-->
<div id="foot_bar">
  Copyright &copy; 1998-2021 Rachid Touzani&nbsp;
</div>
</div> <!-- main -->
</body>
</HTML>
